
1. Java Virtual Machine - 
The Java Virtual Machine (JVM) is a runtime execution engine that provides a platform-independent environment for running Java bytecode. 
Instead of compiling Java code directly into machine-specific instructions, Java source code is first compiled into an intermediate 
format called bytecode. The JVM then interprets or Just-In-Time (JIT) compiles this bytecode into native machine code specific 
to the host operating system and hardware.

Image : 01-jvm.png

============================================================================================================================================

2. Heap Memory
Heap memory is the runtime memory area where all Java objects and instance variables are allocated. 
It is shared among all threads and is managed by the JVM‚Äôs garbage collector.

============================================================================================================================================

3. Object Lifecycle
When an object is created using the new keyword, memory is allocated in the heap and a reference to that object is 
stored (usually on the stack, or within another object). An object remains alive as long as it is reachable through references in the program. 
When no active references point to an object, it becomes eligible for garbage collection.

============================================================================================================================================

4. Memory Reclamation (Garbage Collection)
GC reclaims the memory occupied by unreachable objects so that new objects can use it.
Image : 02-garbage-collection.png

============================================================================================================================================

What is Garbage Collection
Garbage Collection is a process by which Java Virtual Machine automatically manages memory, reclaiming unused objects and freeing heap space.

Java 7 Heap Structure
In this, Java Heap is divided into :

Young Generation
a. Eden Space where all newly created objects are allocated.

b. Survivor Spaces (S0 and S1) ‚Äî two equal-sized memory regions used alternately to hold objects that survive Garbage Collection (GC) in Eden.

2. Old (Tenured) Generation Stores long-lived objects that have survived multiple GC cycles in the Young Generation.

Image L 03-heap-structure.png

============================================================================================================================================


How Objects Move
Every new objects starts in Eden space always. No way for object to go directly in S0 or S1 or old generation. 
When Minor GC runs, JVM picks one survivor space as to-space (empty) and other survivor space as from-space (contains previous survivors).

1. Live objects from Eden are copied into to-space and their age is initialized to 1.
2. Live objects from from-space are also copied into to-space, incrementing their age by 1. 
3. Any object reaching the tenuring threshold (default 15 GCs) is promoted to Old Generation.
4. After copying, Eden and from-space are cleared, and to-space becomes from-space for the next GC.
Example:

First Minor GC: Eden ‚Üí S0 (S1 empty)
Second Minor GC: Eden ‚Üí S1 and S0 ‚Üí S1 (S0 cleared)
Third Minor GC: Eden ‚Üí S0 and S1 ‚Üí S0 (S1 cleared)
‚Ä¶ and so on.


Note : Objects never stay in the same Survivor space across two GCs.
Press enter or click to view image in full size


============================================================================================================================================

Full GC in Java
Full GC is stop the world i.e. it pauses application threads and collects long lived objects in Old or Tenured Generation which are unreferenced. 
Full GC is triggered when Old Generation is full and new objects need promotion from Survivor spaces or we explicitly call system.gc(). 
If Full GC cannot free enough memory (all objects are still reachable), JVM throws:java.lang.OutOfMemoryError: Java heap space.


============================================================================================================================================
PermGen (Java 7 and Earlier)

Permanent Generation (PermGen) was a memory area used to store class-related metadata, including:

Class structure (name, superclass, interfaces, modifiers)

Method metadata (name, parameters, return type, bytecode)

ClassLoader data and JVM internal structures

Static variables (class-level fields)

Cleanup:
Unused classes were removed mainly during Full GC.

Common Issue:
If PermGen memory was exhausted ‚Üí
üëâ java.lang.OutOfMemoryError: PermGen space

============================================================================================================================================

Code Cache
It stores native machine code generated by the JVM‚Äôs JIT compiler. When a method is hot (executed frequently), 
the JVM compiles it once into native instructions and puts it in Code Cache. Subsequent calls to that method run directly 
from native code instead of being interpreted as bytecode each time.

============================================================================================================================================

Types of GC
There are three types of garbage collector in java 7

1. Serial GC :
    Serial GC works using only one thread. When memory starts filling up, it pauses all application threads (Stop-The-World) and begins cleaning.

    First, it checks the Young Generation and removes unused objects ‚Äî this is called Minor GC.
    If memory pressure is high, it cleans the Old Generation (and PermGen in older Java versions) ‚Äî this is called Full GC.

    Serial GC is lightweight and efficient for small applications or single-core systems, but because it is single-threaded, 
    pause times can become longer in large applications.

    Serial GC does not dynamically decide whether to clean Young or Old generation. The JVM heap is already divided into Young Generation 
    and Old Generation, and garbage collection is triggered based on memory usage in these regions.

    When the Young Generation becomes full, Serial GC triggers a Minor GC, which cleans only the Young Generation.

    When the Old Generation becomes full, or when object promotion from Young to Old fails, or under certain memory pressure conditions, 
    Serial GC triggers a Full GC, which cleans the entire heap (Young + Old + PermGen in older Java versions).

  -------------------

2. Parallel GC:
    Inside the JVM, there is a garbage collector called Parallel GC that works with a team instead of working alone.

    When heap memory starts filling up, Parallel GC creates multiple GC threads to scan memory and remove unreferenced 
    objects faster. Before starting cleanup, it pauses all application threads (Stop-The-World), but since many GC threads work together, the pause time is usually shorter than Serial GC on multi-core systems.

    When the Young Generation becomes full, Parallel GC performs Minor GC using multiple threads.
    When the Old Generation needs cleanup, it performs Full GC, also using multiple threads (still Stop-The-World).

    Parallel GC is designed for large heaps and multi-core CPUs, where higher throughput is more important than ultra-low pause time.

    -------------------

3. CMS (Concurrent Mark-Sweep) GC

    Inside the JVM, there is a garbage collector called CMS GC that was built to reduce long pause times.

    CMS mainly cleans the Old Generation while the application is still running. The Young Generation is usually cleaned using a parallel 
    collector with short Stop-The-World pauses.

   
    Because most work happens while the application runs, CMS reduces long pauses and improves application responsiveness, 
    but it uses more CPU and is more complex to manage.

    Steps : 
    1. Initial Mark
        During the Initial Mark phase, the JVM briefly pauses all application threads (Stop-The-World). In this step, 
        the garbage collector marks all objects that are directly reachable from GC Roots, such as objects referenced from thread stacks, 
        static variables, and JNI references. Since it only checks objects directly connected to roots and does not scan the entire heap, 
        this phase is very fast.

    2. Concurrent Mark
        During the Concurrent Mark phase, the JVM resumes application execution and the garbage collector continues its work in parallel. In this step, 
        the GC scans the remaining objects in the Old Generation and marks all objects that are reachable from the objects identified during 
        the Initial Mark phase. It follows object references step-by-step (object graph traversal) to ensure all indirectly reachable objects 
        are marked as live.

        Since this phase runs alongside application threads, the application can still create new objects or change object references.

    3. Concurrent Preclean phase
        During the Concurrent Preclean phase, the garbage collector fixes reference changes that happened while Concurrent Mark was running. 
        Since the application keeps running during Concurrent Mark, it can change object links ‚Äî for example, adding a new reference or 
        removing an old one. The JVM tracks these changes using mechanisms like write barriers and dirty cards, which record which memory 
        areas were modified.

        Simple Example

        Imagine during Concurrent Mark:
            Object A ‚Üí B ‚Üí C (all marked as reachable)

        While marking is still running, application changes reference:
            Object A ‚Üí D (New reference added)
            Object B ‚Üí C link removed

        If GC does nothing, it may:
            Miss marking D (even though it is now reachable)
            Think C is still reachable (even if it may not be)

        During Concurrent Preclean, JVM:
            Re-checks changed areas
            Marks D if reachable
            Updates marking status correctly

        The JVM uses write barriers to monitor when the application updates object references. When a reference is changed, 
        the JVM marks that memory region (called a dirty card) in a tracking structure (card table). During Preclean, 
        GC scans only these dirty cards and updates marking for objects inside those regions. If it finds a new reachable object, 
        it marks it as live.

        Simple Example

        Suppose during Concurrent Mark:
            A ‚Üí B ‚Üí C (All marked live)

        While app is running:
            A ‚Üí D (New reference added)

        Write barrier records that A‚Äôs memory region changed ‚Üí marks card as dirty.

        During Concurrent Preclean:
            GC checks that dirty card
            Sees new reference A ‚Üí D
            Marks object D as reachable (live)

        What Happens If an Object Link Is Removed?
            If a reference (link) to an object is removed during Concurrent Mark, CMS does not immediately unmark that object in 
            the Concurrent Preclean phase.

4. Final Remark
    During the Final Remark phase, the JVM pauses all application threads to complete marking accurately. 
    Since references could still change during Concurrent Mark and Preclean, the GC performs a final check of 
    all remaining reference updates (dirty cards tracked by write barriers).

    Because the application is paused, no references change during this step. This allows the GC to finalize the exact set of 
    reachable (live) objects, ensuring no live object is mistakenly collected. After this, the GC safely moves to the 
    Sweep phase to free memory of unmarked objects.

5. Concurrent Sweep
    During the Concurrent Sweep phase, the garbage collector frees memory occupied by all unmarked objects, which are considered unreachable (garbage).

    This phase runs alongside the application threads, so the application continues running normally without a long pause. 
    However, since CMS uses mark-sweep (without compaction), memory is freed in scattered locations, which can lead to memory fragmentation over time.


-------------------
    Java 8 Metaspace ‚Äî Short, Clear, Optimized Version
        In Java 8, the JVM removed PermGen (Permanent Generation) and replaced it with Metaspace. This change improved memory management, 
        especially for applications that dynamically load and unload classes (like web servers and plugin-based systems).

    ‚úÖ Java 7 ‚Äî PermGen (Old Approach)
        In Java 7:
        PermGen stored class metadata, method metadata, and some JVM internal data.
        It was located inside the JVM heap.
        It had a fixed size, which had to be manually configured.
        In long-running apps with dynamic class loading, it often caused
        üëâ OutOfMemoryError: PermGen space.

    ‚úÖ Java 8 ‚Äî Metaspace (New Approach)
        In Java 8:
        PermGen was removed and replaced with Metaspace.
        Metaspace is allocated in Native Memory (outside JVM heap).
        It is dynamically resizable and grows as needed (until system memory limit or configured limit).
        Stores:
            Class metadata
            Method metadata
            ClassLoader metadata
            Some JVM internal structures

-------------------

G1 GC (experimentally in Java 7, became stable in Java 8)

    Before G1, Java mainly used Serial GC, Parallel GC, and CMS GC.

        Serial GC ‚Üí Single-threaded, full Stop-The-World (STW)
        Parallel GC ‚Üí Multi-threaded, but still STW
        CMS GC ‚Üí Concurrent Old Gen collection, but still had some STW pauses

    ‚úÖ Main Design Limitation
        Heap was divided into Young Gen and Old Gen, and both were continuous memory blocks.

    ‚úÖ Young Generation ‚Äî No Fragmentation Problem
        During Minor GC:
            Surviving objects are copied from Eden + one Survivor ‚Üí other Survivor
            Eden and old Survivor are cleared completely
            ‚úî Memory stays compact
            ‚úî No fragmentation issue
            ‚ùå Old Generation ‚Äî Fragmentation Problem (Especially in CMS)

    In Old Gen:
    After GC, live objects stay in scattered locations
    CMS removes garbage but does not compact memory

    üëâ Total free space may be enough
    üëâ But large object allocation may fail
    üëâ Because free memory is not continuous

    With older garbage collectors, Stop-The-World pauses could become long when heap size increased. 
    This was because the heap was divided into large continuous Young and Old memory blocks, 
    and GC sometimes had to process large areas at once, increasing pause time.

    In G1 GC, the heap is divided into many equal-sized regions instead of large Young and Old spaces. 
    Some regions are marked as Young and others as Old. So logically generations still exist, 
    but physically the heap is just a collection of regions.

    This region-based design helps reduce pause time and fragmentation because G1 can collect only selected regions 
    instead of scanning large memory blocks. Metaspace remains separate and stays in native memory outside the heap.

    Minor GC
        Minor GC (Young GC) in G1 is similar to traditional Minor GC. It collects garbage from Young regions. 
        Surviving objects are either moved to Survivor regions or promoted to Old regions if they reach the age threshold. 
        This process is multi-threaded and Stop-The-World, but optimized for short pauses.

        Example:
        Suppose Young regions contain objects:
        Region Y1 ‚Üí Objects A, B, C
        Region Y2 ‚Üí Objects D, E

        After Minor GC:
        A, D survive ‚Üí moved to Survivor or Old region
        B, C, E are garbage ‚Üí removed

    Full GC
        Full GC in G1 is usually avoided. Normally, G1 runs concurrent marking to find regions with the most garbage and collects them first. Live objects from those regions are copied to another region, freeing the entire source region. This acts like incremental compaction, reducing fragmentation.

        Example:
            Suppose Old regions look like this:
            Region O1 ‚Üí 80% garbage
            Region O2 ‚Üí 30% garbage
            Region O3 ‚Üí 10% garbage

        G1 will collect O1 first.
        If O1 has live objects X and Y ‚Üí They are copied to another region ‚Üí O1 becomes fully free.

    How G1 GC Reduces Pause Time
        Traditional collectors (Serial, Parallel, CMS) collect entire Young Gen or Old Gen at once. When heap is large, this can cause long Stop-The-World pauses.
        G1 solves this by dividing the heap into many equal-sized regions. Instead of collecting an entire generation, G1 collects only selected regions in each GC cycle.

        You can set a pause time target using:
        üëâ -XX:MaxGCPauseMillis=200

        G1 estimates how long it takes to collect one region and then chooses only the number of regions that can be cleaned within the target pause time.
        ‚úÖ Example
        Suppose:
        1 region cleanup ‚âà 20 ms
        Pause target = 200 ms

        G1 will collect:
        üëâ ~10 regions per GC cycle (10 √ó 20 ms ‚âà 200 ms)

        Instead of cleaning the whole heap at once, G1 cleans memory region-by-region, keeping pauses predictable and shorter.

        Java 9 ‚Äî G1 GC Default + Unified JVM Logging (Short + Clear)

        In Java 9, G1 GC became the default garbage collector, replacing Parallel GC. G1 provides more predictable pause times and performs region-based compaction, reducing fragmentation.

        Java 9 also introduced Unified JVM Logging, which standardizes logging across GC, JIT, and other JVM components. 
        Older GC logging flags like -XX:+PrintGCDetails were replaced with the unified format:
        üëâ -Xlog:gc*

        In G1:
            Young GC ‚Üí Parallel (multi-threaded)
            Full GC ‚Üí Usually Stop-The-World fallback (often single-threaded)

        Java 10 Parallel Full GC for G1GC
        Before Java 10, Full GC in G1 was single-threaded, leading to long pauses. Java 10 introduced multi-threaded Full GC, 
        significantly reducing pause times.

    ----------------------------

    