1. JVM Internals (Very Important)
    1. Explain JVM architecture in detail.
    2. How class loading works internally?
    3. What is ClassLoader hierarchy?
    4. What is Metaspace vs PermGen?
    5. How JIT compiler optimizes code?
    6. What is escape analysis?
    7. What is biased locking?
    8. What is lock coarsening and lock elimination?
    9. How JVM handles method inlining?
    10. What happens when OutOfMemoryError occurs?

****************************************************************************************************************************
1. Explain JVM architecture in detail.
    Main Components
        1. Class Loader Subsystem
        2. Runtime Data Areas (Memory)
        3. Execution Engine
        4. Native Method Interface (JNI)
        5. Native Libraries

    1Ô∏è‚É£ Class Loader Subsystem
        It loads your compiled Java code (.class file) into JVM so it can run.
        Think:  .java ‚Üí compile ‚Üí .class ‚Üí Class Loader ‚Üí JVM runs it
        üîπ What is ‚ÄúConverts into runtime structure‚Äù?
            It means:
            JVM reads .class file (bytecode)
            Creates an internal object called Class object
            Stores it in memory so JVM can use it during execution

        üîπ What is Parent Delegation Model? (Most Asked Interview Point)
            üëâ Before loading any class, JVM asks parent class loader first.
            Example Flow:

            Application ClassLoader
            ‚Üì ask
            Extension ClassLoader
            ‚Üì ask
            Bootstrap ClassLoader

            ‚úÖ Why?
            Security (core Java classes can‚Äôt be replaced)
            Avoid duplicate class loading
            Example:
            You cannot override java.lang.String ‚Äî Bootstrap loads it first.

        üîπ What are the 3 Main Phases?
        üü¢ 1. Loading
            JVM reads .class file
            Creates Class object in memory

        üü° 2. Linking
            3 sub-steps:
            Verify ‚Üí Check bytecode is safe
            Prepare ‚Üí Allocate memory for static variables
            Resolve ‚Üí Replace symbolic references with real memory references

        üîµ 3. Initialization
            Runs static blocks
            Assigns static variable values

            Example:
            static int x = 10;
            static { System.out.println("Loaded"); }

    2Ô∏è‚É£ Runtime Data Areas (Memory)
    Defines how JVM memory is organized during execution ‚Äî mainly Heap, Method Area (Metaspace), Stack, PC Register, Native Stack. 
    Heap and Method Area are shared across threads, while Stack and PC Register are thread-specific.

    3Ô∏è‚É£ Execution Engine
    Executes bytecode using Interpreter + JIT Compiler. Interpreter runs code line-by-line initially, while JIT compiles frequently used 
    code into native machine code for performance. Also includes Garbage Collector for automatic memory cleanup.

    4Ô∏è‚É£ Native Method Interface (JNI)
    Acts as a bridge between Java and native languages like C/C++. Enables Java to call OS-level or hardware-specific native libraries 
    when functionality isn‚Äôt available in Java.

    5Ô∏è‚É£ Native Libraries
    Platform-specific compiled libraries (.dll, .so) used by native methods. JVM loads these libraries via JNI when Java programs 
    need low-level system interaction.

    JVM Execution Flow (End-to-End)
        .java ‚Üí Compiler ‚Üí .class (Bytecode) ‚Üí Class Loader ‚Üí Runtime Memory ‚Üí Execution Engine ‚Üí Native / Machine Execution


******************************************************************************************************************************************
2. How class loading works internally?
Refer image for understanding the flow : Java/CoreJava/Misc/302_class_loading_process.png

    The Bootstrap loader is the first loader that kicks-in first.
    
    The Platform Class Loader typically loads JDK platform modules except java.base.
        Database & Enterprise : java.sql, java.sql.rowset
        XML & Web : java.xml, java.xml.crypto
        Logging & Management : java.logging, java.management
        Desktop / UI : java.desktop
        Security : java.security.sasl, java.security.jgss
        Naming : java.naming

******************************************************************************************************************************************
3. What is ClassLoader hierarchy?
    1. The JVM uses a hierarchy of class loaders to load classes.
    2. Each class loader has a parent, forming a tree-like structure.
    3. The hierarchy follows the parent delegation model: a class loader delegates the loading request to its parent before attempting to load the class itself.
    4. The main class loaders in the hierarchy are:
    5. Bootstrap ClassLoader (root, implemented in native code)
    6. Extension (Platform) ClassLoader (child of Bootstrap)
    7. Application (System) ClassLoader (child of Extension)
    8. Custom ClassLoader (user-defined, child of Application or another custom loader)

    Class Loader Hierarchy Diagram:

    Custom ClassLoader
    ‚Üë
    Application (System) ClassLoader
    ‚Üë
    Extension (Platform) ClassLoader
    ‚Üë
    Bootstrap ClassLoader

    Summary Table : 

        | Class Loader                     | Parent Loader               | Loads From                                      |
        | -------------------------------- | --------------------------- | ------------------------------------------------|       
        | Bootstrap ClassLoader            | None (root)                 | JDK core libraries (e.g., java.lang.*), rt.jar  |
        | Extension (Platform) ClassLoader | Bootstrap ClassLoader       | JDK extensions (lib/ext or modules)             |
        | Application (System) ClassLoader | Extension ClassLoader       | Application classpath                           |
        | Custom ClassLoader               | Application or other loader | User-defined sources (network, DB, etc)         |

******************************************************************************************************************************************
4. What is Metaspace vs PermGen?

    PermGen (Permanent Generation):
        Used in JVM before Java 8.
        Stores class metadata, static fields, interned strings.
        Fixed size; can cause java.lang.OutOfMemoryError: PermGen space if exceeded.
        Managed by JVM heap.
            Class metadata (class names, method names, field names, constant pool)
            Method and field information (signatures, access modifiers)
            Static variables (class-level static fields)
            Interned string pool (string literals and interned strings)
            Annotations and reflection data
            Class loader references
            Metadata for methods (bytecode, method tables)
            Information for JIT compilation

    Metaspace:
        Introduced in Java 8, replaces PermGen.
        Stores class metadata outside JVM heap, in native memory.
        Grows dynamically (limited by system memory unless max size is set).
        Reduces OutOfMemoryError risk for class metadata.
        
    | Feature    | PermGen (Java ‚â§7)         | Metaspace (Java ‚â•8)         |
    | ---------- | ------------------------- | --------------------------- |
    | Location   | JVM heap                  | Native memory (OS)          |
    | Size       | Fixed, configurable       | Dynamic, configurable max   |
    | Error      | OutOfMemoryError: PermGen | OutOfMemoryError: Metaspace |
    | Management | JVM                       | OS, JVM                     |


******************************************************************************************************************************************


5. How JIT compiler optimizes code?
    1. The JVM starts by interpreting bytecode.
    2. The JIT (Just-In-Time) compiler monitors code execution and identifies "hot spots" (frequently executed code).
    3. When a method or loop is executed often, the JIT compiles it to native machine code.
    4. The JIT applies optimizations during compilation:
        1. Inlining: Replaces method calls with method bodies.
        2. Loop unrolling: Expands loops to reduce overhead.
            int sum = 0;
            for (int i = 0; i < 4; i++) {
                sum += arr[i];
            }

            replaces with 
            
            int sum = 0;

            sum += arr[0];
            sum += arr[1];
            sum += arr[2];
            sum += arr[3];

        3. Dead code elimination: Removes code that is never executed.
        4. Constant folding: Computes constant expressions at compile time instead of calculating them repeatedly at runtime. int x = 10 * 20; => x = 200
        5. Escape analysis: Allocates objects on the stack if they do not escape the method.
        6. Method devirtualization: Converts virtual calls to direct calls when possible.
    5. The optimized native code is cached and reused for subsequent executions.
    6. The JVM can recompile code with more aggressive optimizations if usage patterns change.


    Analogy : 
        The JIT (Just-In-Time) compiler in the JVM is like a master chef running a fast-paced restaurant kitchen.
        When the restaurant first opens, the kitchen staff follows every recipe step by step from the cookbook. 
        This is like the JVM interpreting bytecode, executing instructions one at a time. It works, but it‚Äôs not the fastest way to cook 
        when orders start piling up.
        
        Meanwhile, the master chef (JIT) is watching the orders coming in. He tracks which dishes are requested again and again. 
        These frequently ordered dishes are like ‚Äúhot spots‚Äù ‚Äî parts of the code that run very often.
        
        When the chef notices a dish becoming popular ‚Äî maybe a special curry or pasta ‚Äî he decides to prepare a faster version of that recipe. 
        In technical terms, when a method or loop runs many times, the JIT compiles the bytecode into native machine code, 
        which the CPU can execute much faster.
        
        While preparing this optimized version, the chef also improves the cooking process using smart tricks:
            Inlining ‚Üí If a recipe depends on small helper steps, the chef merges those steps directly into the main recipe instead of switching between recipe cards.
            Loop Unrolling ‚Üí If he needs to repeat a step many times (like stirring 10 times), he expands it into fewer bigger steps to reduce overhead.
            Dead Code Elimination ‚Üí If a step is never actually needed, he removes it from the recipe completely.
            Constant Folding ‚Üí If some ingredient quantity is always fixed, he calculates it beforehand instead of recalculating every time.
            Escape Analysis ‚Üí If a temporary bowl is only used inside one cooking step, he keeps it on the workstation (stack) instead of storing it in the pantry (heap).
            Method Devirtualization ‚Üí If the chef knows exactly which cooking technique will be used, he goes directly to it instead of checking multiple possibilities.
        
        Once the optimized recipe is ready, the chef stores it in a quick-access recipe book. This is like the JVM caching optimized native code, 
        so the next time the same method runs, it executes instantly.
        
        But this chef is adaptive. If customer taste changes or cooking conditions change, he can throw away the old optimized recipe and 
        create a new one. Similarly, the JVM can recompile code with even more aggressive optimizations if it sees new execution patterns.
        
        Because of this smart system, Java programs may feel a little slow at the very beginning (warm-up phase). But as the JIT chef 
        learns which dishes are most important, performance improves dramatically while the program keeps running.


******************************************************************************************************************************************

6. What is escape analysis?

    Escape analysis is a JVM JIT optimization that determines if an object created inside a method escapes the method/thread.
    If the object does not escape, JVM can:
    Allocate it on the stack (not heap), reducing GC pressure.
    Remove unnecessary synchronization if the object is thread-local.
    Example: Create an object inside a method and use it only within that method (no escape).
    Show how JVM can optimize such code.

    // Example demonstrating escape analysis
    public class EscapeAnalysisExample {

        static class Point {
            int x, y;

            Point(int x, int y) { this.x = x; this.y = y; }
        }

        // This method creates a Point object that does not escape
        public int compute() {
            Point p = new Point(1, 2); // May be stack-allocated
            return p.x + p.y;
        }

        public static void main(String[] args) {
            EscapeAnalysisExample ex = new EscapeAnalysisExample();
            for (int i = 0; i < 1000000; i++) {
                ex.compute();
            }
        }
    }

    In the above, the Point object in compute() does not escape the method.
    JVM may optimize by allocating Point on the stack, not the heap, so no garbage collection is needed for it.
    If you add code that returns p or stores it in a field, the object escapes and this optimization cannot be applied.


******************************************************************************************************************************************
7. What is biased locking?


    In biased locking, the first thread that acquires a lock on an object becomes its ‚Äúowner‚Äù (the lock is biased toward that thread). 
    As long as no other thread tries to acquire the same lock, the owning thread can re-enter the synchronized block without any 
    locking operation (no actual lock acquisition or CAS is needed). So, the thread does not require a traditional lock operation 
    in this case ‚Äî lock acquisition is effectively bypassed for the biased thread.

    If another thread tries to acquire the lock, the JVM revokes the bias and may upgrade to a regular lightweight or heavyweight lock, 
    at which point locking is required.

-----------------------------------------------
    Analogy:
    Imagine a Java object is like a room, and threads are like people trying to enter the room. Normally, to enter, every person must go 
    through a security check (this is normal synchronization locking). This check takes time and system resources.

    Now JVM observes something interesting ‚Äî sometimes only one thread keeps entering the same room again and again. Doing a full security 
    check every time is wasteful. So JVM introduces Biased Locking.

    In biased locking, when the first thread enters the room, JVM says: ‚ÄúOkay, this room mostly belongs to you.‚Äù It marks the object 
    internally with that thread‚Äôs ID (in the object header / mark word). Next time when the same thread comes, it doesn‚Äôt need to do 
    locking again ‚Äî it directly enters. This makes execution very fast because no lock competition or CAS operation is needed.

    But what if another thread suddenly wants to enter the same room? JVM then realizes the room is no longer single-threaded. 
    It revokes the bias, meaning it removes that special ownership and converts the lock into normal locking 
    (lightweight or heavyweight depending on contention). From then on, all threads must follow normal synchronization rules.

    In modern JVM versions, biased locking was removed because CPU architectures and JVM optimizations improved, and the 
    cost-benefit of biased locking reduced in real-world multi-threaded workloads.


******************************************************************************************************************************************
8. What is lock coarsening and lock elimination?
    üîπ 1Ô∏è‚É£ Lock Coarsening
            JVM combines multiple small synchronized blocks into one bigger lock.

            ‚úî Why?
            Repeated lock acquire/release is costly.
            Better to hold one lock for longer than acquire many times.
            ‚úî Example Concept
            Instead of:
            lock ‚Üí unlock ‚Üí lock ‚Üí unlock ‚Üí lock ‚Üí unlock

            JVM converts to:
            lock ‚Üí work ‚Üí work ‚Üí work ‚Üí unlock

            ‚úî Benefit
            Reduces synchronization overhead.
            Improves performance in loop or repeated sync scenarios.

    üîπ 2Ô∏è‚É£ Lock Elimination
            JVM removes locks completely if it detects lock is not needed.
            ‚úî How?
            Uses Escape Analysis.
            If object is used only inside one thread ‚Üí Lock is useless ‚Üí Removed.
            ‚úî Example Concept
            If object never leaves method ‚Üí No multi-thread access ‚Üí No sync needed.

            Lock Coarsening ‚Äî code example
            ‚úÖ Pattern: many small synchronized blocks in a loop
            public class LockCoarseningDemo {
                private final Object lock = new Object();
                private int counter = 0;

                public void work() {
                    for (int i = 0; i < 1000; i++) {
                        synchronized (lock) {     // repeated lock/unlock
                            counter++;
                        }
                    }
                }
            }

            What JIT may do internally (conceptually)
            It may ‚Äúcoarsen‚Äù to something like:

            public void work_coarsened() {
                synchronized (lock) {             // single lock for whole loop
                    for (int i = 0; i < 1000; i++) {
                        counter++;
                    }
                }
            }
            When it helps: repeated locking on the same lock with no blocking points between.

            2) Lock Elimination ‚Äî code example
            ‚úÖ Pattern: synchronized on an object that never escapes the method (thread-local)
            public class LockEliminationDemo {
                public String build() {
                    StringBuffer sb = new StringBuffer(); // StringBuffer methods are synchronized
                    sb.append("Hello");
                    sb.append(" ");
                    sb.append("World");
                    return sb.toString();
                }
            }

            Why lock elimination can happen
            sb is created inside the method and never shared with other threads.
            JIT uses escape analysis to prove it‚Äôs thread-local.
            Then it can remove the internal locks from StringBuffer.append() calls.

******************************************************************************************************************************************
9. How JVM handles method inlining?
    JVM method inlining replaces method calls with actual method code for frequently executed small methods. 
    It reduces call overhead and enables further JIT optimizations.

    üîπ 1. What is Method Inlining?
        JIT replaces a method call with the actual method body.
        Removes method call overhead ‚Üí Improves performance.

    üîπ 2. When JVM Decides to Inline?
        JIT considers:
        Method is small (few bytecode instructions).
        Method is frequently called (Hot method).
        Method is final / static / private (easy to predict target).
        No complex polymorphism (or predictable call site).

    üîπ 3. How JVM Does It Internally?
        Instead of:
        result = add(a, b);

        JIT converts to:
        result = a + b;

        No stack frame creation ‚Üí Faster execution.

******************************************************************************************************************************************
10. What happens when OutOfMemoryError occurs?
    When memory allocation fails, JVM first attempts GC, and if memory is still insufficient, it throws OutOfMemoryError. 
    It is a fatal error and usually indicates memory leak, insufficient memory, or configuration issue.

******************************************************************************************************************************************

