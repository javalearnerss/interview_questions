Angular Fundamentals
    What is Angular and how is it different from AngularJS?
    What are the main building blocks of Angular?
    Explain the role of NgModule.
    What is a standalone component?
    How does Angular bootstrap an application?
    Difference between component and directive?
    What is a pipe? Difference between pure and impure pipes?
    How does data binding work in Angular?

Component Lifecycle
    Explain Angular component lifecycle hooks.
    Difference between ngOnInit and constructor?
    When is ngAfterViewInit used?
    When would you use ngOnDestroy?
    What happens if you don‚Äôt unsubscribe from Observables?

Change Detection
    How does Angular change detection work?
    Difference between Default and OnPush change detection?
    What triggers change detection?
    How does trackBy improve performance?
    How do you manually trigger change detection?

Component Communication
    How do components communicate with each other?
    When to use @Input / @Output?
    How do you communicate between unrelated components?
    What is content projection (ng-content)?
    How does ViewChild work?

RxJS & Observables
    What is an Observable?
    Difference between Observable and Promise?
    What are Subjects? Types of Subjects?
    Difference between switchMap, mergeMap, and concatMap?
    What is shareReplay?
    How do you cancel HTTP requests?
    How do you handle errors in RxJS?

HTTP & Interceptors
    How does HttpClient work?
    What is an HTTP interceptor?
    How do you add auth headers globally?
    How do you handle API errors centrally?
    Difference between retry and retryWhen?

Security
    Where should JWT tokens be stored?
    

Angular 15+ / 16+ / 17+
    What are standalone components?
    What are Angular Signals?
    Signals vs Observables?
    What is zoneless Angular?
    What is hydration in Angular?
    What is deferred loading?




******************************************************************************************************************************************
********* Component Lifecycle ***************
1. Explain Angular component lifecycle hooks.
    Angular creates, updates, and destroys components through a defined sequence of lifecycle events (hooks).
    Important for initialization, responding to input changes, accessing projected content or child views, 
    custom change detection, and cleanup.

    Lifecycle hook order (most common)

        1. constructor (not an Angular hook ‚Äî class instantiation)
        2. ngOnChanges(changes: SimpleChanges) ‚Äî whenever input-bound properties change (called before ngOnInit on first change)
        3. ngOnInit() ‚Äî once after first ngOnChanges
        4. ngDoCheck() ‚Äî developer hook for custom change detection (runs frequently)
        5. ngAfterContentInit() ‚Äî after content projection (<ng-content>) is initialized
        6. ngAfterContentChecked() ‚Äî after every check of projected content
        7. ngAfterViewInit() ‚Äî after the component‚Äôs view (and child views) are initialized
        8. ngAfterViewChecked() ‚Äî after every check of the component‚Äôs view (and child views)
        9. ngOnDestroy() ‚Äî just before Angular destroys the component

    Detailed description of each hook

        constructor()

        Runs when the class is instantiated.
            Use it to inject dependencies. Avoid side effects or DOM/Angular-dependent logic.
        
        ngOnChanges(changes: SimpleChanges)
            ngOnChanges runs whenever an @Input() value changes.
            It tells you:
                What was the old value
                What is the new value
            -  Runs before ngOnInit (first time)
            -  Runs every time parent updates input

            @Input() age!: number;

            ngOnChanges(changes: SimpleChanges) {
                console.log(changes['age'].previousValue);
                console.log(changes['age'].currentValue);
            }
        -------------------------------------------------------------------------
            
        ngOnInit()
            Runs once after the first ngOnChanges
            Runs when component is ready and inputs have values
        
        @Input() userId!: number;

        ngOnInit() {
            console.log('Fetch data for user:', this.userId);
        }

        -------------------------------------------------------------------------        
            
        ngDoCheck() : runs every time Angular checks the screen for changes. It runs when something is changed on the screen.
                Runs many times
                Use only if normal Angular change detection is not enough
        
        ngOnChanges ‚Üí Runs when new book is given
        ngDoCheck ‚Üí Teacher checking book again and again

        @Input() user!: { name: string; age: number };

        ngDoCheck() {
            console.log('Checking...');
        }

        Parent Changes Age (Wrong Way)
        this.user.age++; // object same, only value changed

        Hook	            Runs?
        ngOnChanges	        ‚ùå No (object reference same)
        ngDoCheck	        ‚úÖ Yes (runs every check)

        Note : Angular runs change detection whenever something might have changed in your app state.

        -------------------------------------------------------------------------  
                
        ngAfterContentInit() : runs once after content from parent is placed inside <ng-content>.
            1. Runs once
            2. Runs after projected content is ready

        What is Projected Content?
        When parent sends HTML inside child component.

        Child Component HTML
        <div>
            <h3>User Card</h3>
            <ng-content></ng-content>   
        </div>

        Parent Uses Child
        <app-user-card>
            <p>This comes from parent</p>
        </app-user-card>

        Lifecycle
        Parent content ‚Üí goes inside <ng-content>  
        Then ‚Üí ngAfterContentInit runs

        When To Use (Simple)
            ‚úî Read projected content
            ‚úî Run logic after projected content exists 
        -------------------------------------------------------------------------  
        
        ngAfterContentChecked() : runs every time Angular checks projected content (<ng-content>).
             1. Runs many times
             2. Use only for light checks

        Child HTML
        <ng-content></ng-content>

        Child TS
        ngAfterContentChecked() {
            console.log('Content checked');
        }

        Parent
        <app-user-card>
            <p>{{ message }}</p>
        </app-user-card>


        If message changes ‚Üí
        - Angular checks content ‚Üí
        - ngAfterContentChecked() runs

        -------------------------------------------------------------------------  

        ngAfterViewInit()
            Called once after the component‚Äôs view and child views are initialized.
            Good for DOM-dependent initialization (e.g., working with @ViewChild, third-party libraries that need elements).
        
        ngAfterViewChecked()
            Called after every change-detection check of the component‚Äôs view and child views.
            Avoid heavy work; can cause infinite loops if you change data that triggers another check.

        -------------------------------------------------------------------------        
        ngOnDestroy()
            Called just before Angular destroys the component.
            Use to clean up: unsubscribe from Observables, remove event listeners, cancel timers, detach resources to avoid memory leaks.
        
        Why Use It
            1. Use it to clean up:
            2. Unsubscribe Observables
            3. Remove event listeners
            4. Clear timers
            5. Stop background work
        
        subscription!: Subscription;

        ngOnInit() {
            this.subscription = interval(1000).subscribe();
        }

        ngOnDestroy() {
            this.subscription.unsubscribe();
        }
        Prevents memory leak

        Another Simple Example (Timer)
        timer!: any;

        ngOnInit() {
            this.timer = setInterval(() => console.log('Running'), 1000);
        }

        ngOnDestroy() {
            clearInterval(this.timer);
        }

******************************************************************************************************************************************
2. Difference between ngOnInit and constructor?

    When they run
    constructor: runs when the class is created (before Angular has set input properties or done any data binding).
    ngOnInit: runs shortly after construction and after Angular has processed input bindings (and after the first ngOnChanges if any).
   
    Primary purpose
    constructor: inject services, set simple defaults, keep it fast and side-effect free.
    ngOnInit: perform initialization logic, start async work (HTTP calls, subscriptions), or compute values that require input values.

******************************************************************************************************************************************
3. When is ngAfterViewInit used?

    When it runs (where it sits in the lifecycle)
        Sequence around it: constructor ‚Üí ngOnChanges (if any) ‚Üí ngOnInit ‚Üí ngAfterContentInit ‚Üí ngAfterContentChecked ‚Üí ngAfterViewInit ‚Üí ngAfterViewChecked.
        It runs once, after the view (and child component views) are created and rendered for the first time.
        
    Common uses
        Accessing @ViewChild or @ViewChildren references safely:
            Read DOM properties (size, position), call nativeElement.getBoundingClientRect(), etc.
            Call methods on child components.
        Initializing third-party libraries that need real DOM elements (charts, sliders, maps).
        Starting animations that require final DOM layout.

******************************************************************************************************************************************
4. When would you use ngOnDestroy?
    Use ngOnDestroy to run cleanup logic just before Angular destroys a component or directive. It‚Äôs where you release resources so they 
    don‚Äôt leak or keep producing side effects after the component is gone.
    
    When ngOnDestroy runs
        - Called once, synchronously, right before Angular removes the component/directive from the DOM (for route changes, *ngIf false, parent destroyed, etc.).
        - Child components/directives are destroyed before their parent.

******************************************************************************************************************************************
5. What happens if you don‚Äôt unsubscribe from Observables?
    If you don‚Äôt unsubscribe from long‚Äëlived (non‚Äëcompleting) Observables, your subscriptions keep receiving values after the component is gone. 
    That commonly causes memory leaks, unexpected side effects, duplicate handlers, and runtime errors (because callbacks reference destroyed 
    component state).

******************************************************************************************************************************************
************* Change Detection ***********
1. How does Angular change detection work?
    1. Angular uses change detection to update the UI when application state changes.
        User Action (UI) ‚Üí Event Handler (TypeScript) ‚Üí State Changes ‚Üí Angular Change Detection Runs ‚Üí UI Updates
        Example:
            User clicks button ‚Üí Counter increases ‚Üí UI should show new number
            API returns data ‚Üí UI should show new data


    2. The framework creates a component tree and runs change detection to check if data-bound properties have changed.
        AppComponent
            ‚îú HeaderComponent
            ‚îú ProductListComponent
            ‚îî FooterComponent
        
        Angular goes through this tree and checks:
             Did any component data change?
             If yes ‚Üí Update UI
             If no ‚Üí Do nothing

        Angular tracks:
            Interpolation ‚Üí {{ value }}
            Property binding ‚Üí [disabled]="isLoading"
            Input values ‚Üí @Input()

        By default Angular runs change detection when:
        ‚úÖ Button click
        ‚úÖ HTTP response
        ‚úÖ Timer (setTimeout / setInterval)
        ‚úÖ Promise resolved
        ‚úÖ Observable emits
        ‚úÖ User input


    3. By default, Angular uses Zone.js to detect async events (HTTP, timers, user input) and automatically triggers change detection.
        1. Zone.js is like a watcher around your app
        2. It tracks async operations
        3. When async work finishes ‚Üí It tells Angular ‚Üí ‚ÄúRun change detection now‚Äù

        Note : You normally don‚Äôt use Zone.js directly ‚Äî Angular uses it internally.
    HTTP Call Finished ‚Üí Zone.js detects async completion ‚Üí Zone.js notifies Angular ‚Üí Angular runs Change Detection ‚Üí UI updates automatically 


    4. Each component has a change detector that checks for changes in its template and updates the DOM if needed.
        Every Angular component has an internal watcher.
        This watcher:
            1Ô∏è‚É£ Checks component data
            2Ô∏è‚É£ Compares with previous value
            3Ô∏è‚É£ If changed ‚Üí Updates HTML (DOM)

    5. Change detection can be triggered manually (e.g., via ChangeDetectorRef) or automatically (default).
        Why Do We Need Manual Change Detection?
        Main cases:
            ‚úî OnPush + object mutation
            ‚úî Code running outside Angular zone
            ‚úî Third-party library callbacks
            ‚úî Performance optimization
        
        Real Example ‚Äî OnPush + Mutation Problem
        - Child Component (OnPush)
            import { ChangeDetectionStrategy, Component, Input } from '@angular/core';

            @Component({
            selector: 'app-child',
            template: `<h2>{{ user.name }} - {{ user.age }}</h2>`,
            changeDetection: ChangeDetectionStrategy.OnPush
            })
            export class ChildComponent {
            @Input() user!: { name: string; age: number };
            }

        - Parent Component (Problem Case)
        @Component({
        template: `
            <app-child [user]="user"></app-child>
            <button (click)="increaseAge()">Increase Age</button>
        `
        })
        export class ParentComponent {

            user = { name: 'Sandeep', age: 25 };

            increaseAge() {
                this.user.age++;   // Mutation ‚ùå
            }
        }

        Problem
        OnPush checks only: Input reference change but not Internal property mutation

        So UI may NOT update.
        ‚úÖ Fix Using ChangeDetectorRef (Manual)
        Parent Component (Manual Fix)
        import { ChangeDetectorRef } from '@angular/core';

            constructor(private cdr: ChangeDetectorRef) {}

            increaseAge() {
            this.user.age++;      // Mutation
            this.cdr.detectChanges();   // Manual trigger ‚úÖ
        }

    6. There are two strategies: Default (checks all components) and OnPush (checks only when inputs change or events occur).
   
   
******************************************************************************************************************************************
3.  Difference between Default and OnPush change detection?
    Default change detection checks all components in every cycle, while OnPush checks a component only when its input reference changes, 
    an event occurs inside it, or it is manually triggered, which improves performance.

    1. Default Example
        Child Component (Default)
        @Component({
        selector: 'app-child',
        template: `Age: {{ user.age }}`
        })
        export class ChildComponent {
        @Input() user!: { name: string; age: number };
        }

        Parent Component
        @Component({
        template: `
            <app-child [user]="user"></app-child>
            <button (click)="increaseAge()">Increase Age</button>
        `
        })
        export class ParentComponent {

            user = { name: 'Sandeep', age: 25 };

            increaseAge() {
                this.user.age++;   // Mutation
            }
        }

        What Happens (Default)
            Button Click
            ‚Üì
            Angular runs change detection
            ‚Üì
            Child checked
            ‚Üì
            Template sees new age
            ‚Üì
            UI Updates 


        Even mutation works.

    2. OnPush Example
        Child Component (OnPush)
        @Component({
        selector: 'app-child',
        template: `Age: {{ user.age }}`,
        changeDetection: ChangeDetectionStrategy.OnPush
        })
        export class ChildComponent {
        @Input() user!: { name: string; age: number };
        }

        Parent Component (Same Code)
        increaseAge() {
            this.user.age++;   // Mutation ‚ùå
        }

        What Happens (OnPush)
        Button Click
        ‚Üì
        Angular checks Parent
        ‚Üì
        Child Input reference SAME
        ‚Üì
        Child NOT checked
        ‚Üì
        UI NOT updated


******************************************************************************************************************************************
4. How does trackBy improve performance?

    trackBy helps Angular avoid re-rendering entire lists when using *ngFor.
      Without trackBy ‚Üí Angular may recreate all DOM elements
      With trackBy ‚Üí Angular updates only changed items

    Problem Without trackBy
    Angular tracks list items by object reference (memory address) by default.
    If array changes ‚Üí Angular may think all items are new ‚Üí Rebuild DOM ‚Üí Slow for big lists.

    Example Without trackBy
    Component
    users = [
    { id: 1, name: 'Sandeep' },
    { id: 2, name: 'Rahul' }
    ];

    refreshList() {
        this.users = [...this.users]; // New reference but same data
    }

    Template
    <div *ngFor="let user of users">
    {{ user.name }}
    </div>

    ‚ùå What Happens
    Array reference changed
    ‚Üì
    Angular recreates ALL DOM elements
    ‚Üì
    Performance waste

    Solution ‚Äî Using trackBy
    trackBy tells Angular:
     ‚ÄúIdentify each item using this unique value‚Äù

    Usually ‚Üí ID

    Example With trackBy
    Component
    trackByUserId(index: number, user: any) {
        return user.id;
    }

    Template
    <div *ngFor="let user of users; trackBy: trackByUserId">
        {{ user.name }}
    </div>

    What Happens
    Array reference changed
    ‚Üì
    Angular checks IDs
    ‚Üì
    Only changed items updated
    ‚Üì
    DOM reuse ‚Üí Faster performance

    Real Performance Impact
    Imagine:
    1000 list items
    Only 1 item updated

    Without trackBy
    ‚ùå Recreate 1000 DOM nodes
    With trackBy
    ‚úÖ Update only 1 DOM node
   
******************************************************************************************************************************************
5. How do you manually trigger change detection?
    You manually trigger change detection using ChangeDetectorRef.
     It is used when Angular does NOT automatically detect changes
     Mostly used with OnPush, performance tuning, or external callbacks

       import { Component, ChangeDetectorRef } from '@angular/core';

        @Component({
        selector: 'app-demo',
        template: `
            <h2>{{ name }}</h2>
            <button (click)="updateName()">Update</button>
        `
        })
        export class DemoComponent {

            name = 'Sandeep';

            constructor(private cdr: ChangeDetectorRef) {}

            updateName() {
                this.name = 'Rahul';
                this.cdr.detectChanges();   // Manual trigger
            }
        }

        Real Scenario Example (OnPush + Mutation)
        increaseAge() {
            this.user.age++;        // Mutation
            this.cdr.detectChanges();   // Force UI update
        }


*********** Component Communication ************
1. How do components communicate with each other?
    Components communicate in many ways. Choose depending on relationship:
        Parent ‚Üî Child: @Input / @Output (EventEmitter), @ViewChild, template refs
        Siblings: via the parent (propagate through Inputs/Outputs) or via a shared service
        Unrelated or distant components: shared service (Subjects/BehaviorSubjects), global state (NgRx/Akita, etc.), Router params, or Signals
        Projected content: ContentChild / <ng-content>
        Forms: ControlValueAccessor for custom form controls

    When to use each
        Use @Input / @Output for simple parent-child data + events (keeps components decoupled and testable).
        Use @ViewChild when the parent must call methods or access properties on a specific child instance.
        Use a shared service for cross-tree or sibling communication, especially when components aren‚Äôt related by direct nesting.
        Use a state management library (NgRx, etc.) for large apps with complex state and many subscribers.
        Use Router params for navigation-driven data.
        Use Signals (Angular 16+) for reactive state that many components read; services can expose signals.

******************************************************************************************************************************************
2. When to use @Input / @Output?
    Use @Input and @Output when parent and child components need to communicate directly.

    Child component : 
   



******************************************************************************************************************************************
3. How do you communicate between unrelated components?
    Use a shared injectable service (the usual and recommended way) ‚Äî expose an Observable/Signal for consumers and methods to update it.

    Recommended approach (shared service)
        Make the service a singleton (providedIn: 'root' or provided in a parent module).
        Expose a readonly Observable (or Signal) to subscribe/read from.
        Emit/modify via methods on the service.
        Consumers either use the async pipe (preferred) or subscribe with proper cleanup (takeUntil / unsubscribe).
    
    When to use Subject vs BehaviorSubject vs ReplaySubject
        Subject: no initial value; subscribers only receive emissions that happen after they subscribe.
        BehaviorSubject<T>: has a current value and immediately emits the latest value to new subscribers ‚Äî good for current-state scenarios.
        ReplaySubject: replays a specified number of past values to new subscribers.
    
    Note : Why avoid EventEmitter in services
            EventEmitter is intended for @Output in components; use Subjects/Observables for services.

    1. message.service.ts
        import { Injectable } from '@angular/core';
        import { BehaviorSubject, Observable } from 'rxjs';

        @Injectable({ providedIn: 'root' })
        export class MessageService {
                // internal subject keeping the latest message
                private readonly _message$ = new BehaviorSubject<string | null>(null);

                // public read-only observable
                readonly message$: Observable<string | null> = this._message$.asObservable();

                send(message: string) {
                    this._message$.next(message);
                }

                clear() {
                    this._message$.next(null);
                }
        }
    
    2. sender.component.ts
        import { Component } from '@angular/core';
        import { MessageService } from './message.service';

        @Component({
        selector: 'app-sender',
        template: `
            <div style="border:1px solid #cfc; padding:8px">
            <h4>Sender</h4>
            <input [(ngModel)]="text" placeholder="Type a message" />
            <button (click)="send()">Send</button>
            </div>
        `
        })
        export class SenderComponent {
            text = '';

            constructor(private msg: MessageService) {}

            send() {
                if (this.text.trim()) {
                this.msg.send(this.text.trim());
                this.text = '';
                }
            }
        }
    
    3. receiver.component.ts
        import { Component } from '@angular/core';
        import { MessageService } from './message.service';

        @Component({
        selector: 'app-receiver',
        template: `
            <div style="border:1px solid #ccf; padding:8px; margin-top:8px">
            <h4>Receiver (async pipe)</h4>
            <div *ngIf="msgService.message$ | async as m; else none">
                Latest message: <strong>{{ m }}</strong>
            </div>
            <ng-template #none><em>No messages</em></ng-template>
            </div>
        `
        })
        export class ReceiverComponent {
        constructor(public msgService: MessageService) {}
        }
    
    Key points in this example
        1. Sender and Receiver are unrelated components (not parent/child) but communicate through the singleton MessageService.
        2. Receiver uses the async pipe so it doesn‚Äôt need to manually unsubscribe.
        3. Service API encapsulates how messages are produced/consumed.

******************************************************************************************************************************************
4. What is content projection (ng-content)?
    Content projection means:
    - Parent can put HTML/content inside a child component
    - Child shows that content using <ng-content>

    It helps create reusable wrapper components (card, modal, layout, etc.).

    Simple Example
    üîπ Child Component
        <div class="card">
            <h3>User Card</h3>
            <ng-content></ng-content>
        </div>

    üîπ Parent Component
        <app-user-card>
            <p>User Name: Sandeep</p>
        </app-user-card>

    What Happens
    - Parent writes content inside <app-user-card>
    - Angular inserts it where <ng-content> is placed

    Output:
        User Card
        User Name: Sandeep  

    Why Use It
        ‚úî Create reusable UI wrappers
        ‚úî Flexible layouts
        ‚úî Pass full HTML instead of only data

    hotel-card component html
        <div class="card">
            <div class="card-header">
                <ng-content select="[header]"></ng-content>
            </div>

            <div class="card-body">
                <ng-content></ng-content>
            </div>

            <div class="card-footer">
                <ng-content select="[footer]"></ng-content>
            </div>
        </div>

    search component html
        <app-hotel-card>

            <div header>
                Taj Hotel ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
            </div>

            <div>
                Location: Mumbai <br>
                Price: ‚Çπ8000 / night
            </div>

            <div footer>
                <button>Book Now</button>
            </div>

        </app-hotel-card>

    When to Use Content Projection
    1. Reusable UI Wrapper Components : When structure is fixed, but content changes.
    2. When Parent Should Control Inner Content : Child controls layout, Parent controls what appears inside
    3. When You Don‚Äôt Want Too Many @Input Properties : Instead of passing many strings/HTML via inputs, Just project real HTML

******************************************************************************************************************************************
5. How does ViewChild work?
    ViewChild lets a component access elements or child components inside its own HTML (view).

    1. Access DOM element
    2. Access child component methods / properties

    Access DOM Element Using ViewChild
    Ex. When booking page loads ‚Üí you want to auto focus the search input box, So user can start typing immediately without clicking.
       Parent HTML
        <input #nameInput type="text" />
        <button (click)="focusInput()">Focus Input</button>

      Parent TS
        import { Component, ViewChild, ElementRef, AfterViewInit } from '@angular/core';

        @Component({
        selector: 'app-parent',
        templateUrl: './parent.component.html'
        })
        export class ParentComponent implements AfterViewInit {

            @ViewChild('nameInput') input!: ElementRef;

            ngAfterViewInit() {
                console.log(this.input.nativeElement.value);
            }

            focusInput() {
                this.input.nativeElement.focus();
            }
        }

        What Happens
        #nameInput ‚Üí template reference variable
        @ViewChild('nameInput') ‚Üí gets that element
        ElementRef ‚Üí gives access to real DOM
    
    ----------------------------------------------------------------

    Access Child Component Using ViewChild
     Child Component
        @Component({
        selector: 'app-child',
        template: `<p>Child Works!</p>`
        })
        export class ChildComponent {

            message = "Hello from Child";

            showAlert() {
                alert("Child Method Called");
            }
        }

     Parent HTML
        <app-child></app-child>

        <button (click)="callChild()">Call Child Method</button>

     Parent TS
        import { Component, ViewChild, AfterViewInit } from '@angular/core';
        import { ChildComponent } from './child.component';

        @Component({
        selector: 'app-parent',
        templateUrl: './parent.component.html'
        })
        export class ParentComponent implements AfterViewInit {

            @ViewChild(ChildComponent) child!: ChildComponent;

            ngAfterViewInit() {
                console.log(this.child.message);
            }

            callChild() {
                this.child.showAlert();
            }
        }

        What Happens
            Angular finds <app-child>
            Gives parent direct access to child instance
            Parent can call methods / read properties

******************************************************************************************************************************************
******************** RxJS & Observables ***************
1. What is an Observable?
    An Observable (from RxJS) is a lazy, push-based stream of values over time ‚Äî a sequence you can subscribe to in order to receive values, 
    errors, and a completion signal.
    
    Key concepts
        1. Producer vs consumer: the Observable is the producer; subscribers are consumers.
        2. Subscription: you call subscribe(...) to start receiving values.
        3. Notifications: next (value), error (terminal error), complete (terminal success).
        4. Lazy: nothing runs until you subscribe.
        5. Cancelable: subscription.unsubscribe() stops receiving values and (usually) cancels the underlying work.
        6. Operators: pure functions (map, filter, switchMap, debounceTime, catchError, etc.) transform streams via pipe().

    import { Observable } from 'rxjs';

    const obs = new Observable<number>((subscriber) => {
        subscriber.next(1);
        subscriber.next(2);
        subscriber.next(3);
        subscriber.complete();
    });

    const sub = obs.subscribe({
        next: v => console.log('value', v),
        error: err => console.error('error', err),
        complete: () => console.log('done'),
    });

    // unsubscribe if needed
    sub.unsubscribe();

    two (or more) components can communicate using Observables. The usual pattern is to put an RxJS Subject/BehaviorSubject/etc. 
    in a shared service that both components inject: one component pushes values (calls next) and the other subscribes 
    (or uses the async pipe) to receive them.

    1. message.service.ts
        import { Injectable } from '@angular/core';
        import { BehaviorSubject, Observable } from 'rxjs';

        @Injectable({ providedIn: 'root' })
        export class MessageService {
            // private subject holds the value and allows next()
            private messageSubject = new BehaviorSubject<string | null>(null);

            // public observable read-only view
            message$: Observable<string | null> = this.messageSubject.asObservable();

            // call to send a message
            send(message: string) {
                this.messageSubject.next(message);
            }

            // optionally clear
            clear() {
                this.messageSubject.next(null);
            }
        }

    2. sender.component.ts
        import { Component } from '@angular/core';
        import { MessageService } from './message.service';

        @Component({
        selector: 'app-sender',
        templateUrl: './sender.component.html'
        })
        export class SenderComponent {
            constructor(private msg: MessageService) {}

            sendHello() {
                this.msg.send('Hello from Sender at ' + new Date().toLocaleTimeString());
            }
        }

    3. receiver.component.ts
        import { Component, OnDestroy } from '@angular/core';
        import { MessageService } from './message.service';
        import { Subject, takeUntil } from 'rxjs';

        @Component({
        selector: 'app-receiver-sub',
        template: `<div>{{ latest }}</div>`
        })
        export class ReceiverWithSubscriptionComponent implements OnDestroy {
            latest: string | null = null;
            private destroy$ = new Subject<void>();

            constructor(private msg: MessageService) {
                this.msg.message$
                .pipe(takeUntil(this.destroy$))
                .subscribe(value => {
                    this.latest = value;
                    // do other imperative work here
                });
            }

            ngOnDestroy() {
                this.destroy$.next();
                this.destroy$.complete();
            }
        }

******************************************************************************************************************************************
2. Difference between Observable and Promise?

    Promise:
        Runs immediately, returns one value (or error) once, and has no native cancellation. Best for single async results.

        const p = new Promise<number>((resolve) => {
            console.log('Promise executor runs immediately');
            setTimeout(() => resolve(42), 1000);
        });

        p.then(v => console.log('Promise resolved', v));

    Observable:
        Runs only when subscribed, can return multiple values over time, and can be cancelled using unsubscribe(). 
        Best for streams, events, and reactive patterns.
    
        import { Observable } from 'rxjs';

        const obs = new Observable<number>(subscriber => {
            console.log('Observable producer runs only on subscribe');
            let i = 0;
            const id = setInterval(() => subscriber.next(++i), 500);

            // cleanup on unsubscribe
            return () => {
                clearInterval(id);
                console.log('cleanup after unsubscribe');
            };
        });

        const sub = obs.subscribe(v => console.log('value', v));
        setTimeout(() => sub.unsubscribe(), 1600); // stops the stream

******************************************************************************************************************************************
3.  What are Subjects? Types of Subjects?
    A Subject is a special type of Observable that is also an Observer.

    - It can emit values (like Observer)
    - It can be subscribed to (like Observable)

    Simple Technical Meaning
        Normal Observable ‚Üí Data flows from producer ‚Üí subscribers
        Subject ‚Üí You can manually push data using .next()

    Basic Example
        import { Subject } from 'rxjs';

        const subject = new Subject<number>();

        subject.subscribe(v => console.log('A:', v));
        subject.subscribe(v => console.log('B:', v));

        subject.next(1);
        subject.next(2);

        Output
        A: 1
        B: 1
        A: 2
        B: 2

        All subscribers get same value ‚Üí multicast

        Types of Subjects
        üîπ Subject
            Basic multicast stream.
            Does not store previous values ‚Äî new subscribers only receive future emissions.
            Used for simple event broadcasting.

        üîπ BehaviorSubject
            Requires an initial value and always holds the latest value.
            New subscribers immediately receive the current/latest value.
            Commonly used for app state (user data, theme, shared state).

        üîπ ReplaySubject
            Stores and replays the last N emitted values to new subscribers.
            Useful when new subscribers need some history of previous emissions.

        üîπ AsyncSubject
            Emits only the last value, and only after complete() is called.
            Useful when you only care about the final result after a process finishes.


******************************************************************************************************************************************
4.  How do you cancel HTTP requests?

    Angular HTTP returns Observables, so cancellation works by stopping the subscription.
    When subscription stops ‚Üí browser cancels network request (XHR / fetch abort).

    1. unsubscribe() ‚Äî Manual Cancellation
        You manually stop listening to the response. When you unsubscribe ‚Üí Angular aborts the HTTP request.

        Example
            const sub = this.http.get('/api/hotels').subscribe({
                next: data => console.log(data)
            });

            // Cancel after 1 second
            setTimeout(() => {
            sub.unsubscribe();
            console.log('Request Cancelled');
            }, 1000);

    What Happens : Request starts, Before response arrives ‚Üí unsubscribe(), Browser cancels network request

    When Used : One-off requests, Manual control situations

    ---------------------------------------------------------------------------------

    2. switchMap() ‚Äî Auto Cancel Previous Request 
        When a new request starts ‚Üí old request is automatically cancelled. Perfect for search typing, filters, dropdown selection.

        Example (Search Box)
        searchInput.valueChanges.pipe(
            switchMap(text => this.http.get(`/api/search?q=${text}`))
        ).subscribe(result => console.log(result));

    ---------------------------------------------------------------------------------
    3. takeUntil() ‚Äî Cancel on Component Destroy
           Used to stop requests when component is destroyed (navigation, page change). Prevents memory leaks.

        Example
        private destroy$ = new Subject<void>();

        ngOnInit() {
        this.http.get('/api/bookings')
            .pipe(takeUntil(this.destroy$))
            .subscribe(data => console.log(data));
        }

        ngOnDestroy() {
            this.destroy$.next();
            this.destroy$.complete();
        }

        What Happens
            Request runs normally
            When component destroyed ‚Üí destroy$ emits
            Observable stops ‚Üí request cancelled

        When Used
            Almost every Angular component
            Long-lived streams

******************************************************************************************************************************************

5. How do you handle errors in RxJS?
    Error Handling in RxJS (Short)
    üîπ subscribe(error)
        Handle error at subscription level.
        obs$.subscribe({ error: err => console.log(err) });

    üîπ catchError() 
        Catch error inside stream and return fallback value.
        obs$.pipe(catchError(err => of([])));

    üîπ retry()
        Retry failed request automatically.
        obs$.pipe(retry(2));

    üîπ finalize()
        Runs on success OR error (cleanup, stop loader).
        obs$.pipe(finalize(() => stopLoader()));    

******************************************************************************************************************************************
*************** HTTP & Interceptors *************
1. How does HttpClient work?


******************************************************************************************************************************************
2. What is an HTTP interceptor?
3. How do you add auth headers globally?
4. How do you handle API errors centrally?
5. Difference between retry and retryWhen?


******************************************************************************************************************************************

***** Angular 15+ / 16+ / 17+ *********
1. What are standalone components?
    Standalone components in Angular (introduced in v14+) are components that do not require inclusion in an NgModule. 
    They are self-contained and can directly declare their own dependencies (other components, directives, pipes) via the imports property.

    Key points:
        No need to declare in an NgModule.
        Use the standalone: true flag in the component decorator.
        Dependencies are listed in the imports array.
        Can be used directly in routing or bootstrapped as root components.

        import { Component } from '@angular/core';
        import { CommonModule } from '@angular/common';

        @Component({
        selector: 'app-standalone',
        template: `<h1>Standalone Component</h1>`,
        standalone: true,
        imports: [CommonModule]
        })
        export class StandaloneComponent {}

    When components are not standalone components then they are defined in the NgModule and all the dependencies are provided through imports.
    NgModules are typically defined in files ending with .module.ts. The main application module is usually in src/app/app.module.ts. 
    Feature modules are defined in their own files, such as src/app/feature/feature.module.ts.

        Example file:
        src/app/app.module.ts

        Example definition:
        // src/app/app.module.ts
        import { NgModule } from '@angular/core';
        import { BrowserModule } from '@angular/platform-browser';
        import { AppComponent } from './app.component';

        @NgModule({
        declarations: [AppComponent],
        imports: [BrowserModule],
        providers: [],
        bootstrap: [AppComponent]
        })
        export class AppModule {}


******************************************************************************************************************************************
2. What are Angular Signals?
    A signal is a wrapper around a value that notifies interested consumers when that value changes. Signals can contain any value, 
    from primitives to complex data structures. You read a signal's value by calling its getter function, which allows Angular to track 
    where the signal is used.
    Signals may be either writable or read-only.


    - Writable signals :
        Writable signals provide an API for updating their values directly. 
        You create writable signals by calling the signal function with the signal's initial value:

        const count = signal(0);
        // Signals are getter functions - calling them reads their value.
        console.log('The count is: ' + count());
        
        To change the value of a writable signal, either .set() it directly:
        count.set(3); 
        
        or use the .update() operation to compute a new value from the previous one:
        // Increment the count by 1.
        count.update((value) => value + 1);
    
    - Converting writable signals to readonly
        WritableSignal provide a asReadonly() method that returns a readonly version of the signal. 
        This is useful when you want to expose a signal's value to consumers without allowing them to modify it directly:

        @Injectable({providedIn: 'root'})
        export class CounterState {
            // Private writable state
            private readonly _count = signal(0);
            readonly count = this._count.asReadonly(); // public readonly
            increment() {
                this._count.update((v) => v + 1);
            }
        }

        @Component({
        /* ... */
        })
        export class AwesomeCounter {
            state = inject(CounterState);
            count = this.state.count; // can read but not modify
            increment() {
                this.state.increment();
            }
        }
    
        The readonly signal reflects any changes made to the original writable signal, but cannot be modified using set() or update() methods.

******************************************************************************************************************************************
4. Signals vs Observables?
    Think simply:
      Signals ‚Üí State (value over time)
      Observables ‚Üí Streams (events over time)

    State = Current data/value that represents UI or app condition
        It answers:
        ‚ÄúWhat is the current situation right now?‚Äù
            Examples of state:
            Is user logged in? ‚Üí true / false
            Cart items count ‚Üí 3
            Loading spinner visible? ‚Üí true / false
            Selected theme ‚Üí "dark"

    Observables ‚Äî Async Streams (Simple Meaning)
        Observable = A stream of values coming over time (usually async)

        Instead of holding one current value (state),
        Observables handle multiple values/events happening over time.

        What Is ‚ÄúAsync Stream‚Äù (Simple)
        Break it:
            Async ‚Üí Happens later / not immediately (API, timers, user input)
            Stream ‚Üí Multiple values coming one after another

        Real Life Analogy
        Water Tap
            Signal ‚Üí Water level in bucket (current state)
            Observable ‚Üí Water flowing from tap (continuous stream)

******************************************************************************************************************************************
    What is zoneless Angular?
    What is hydration in Angular?
    What is deferred loading?
******************************************************************************************************************************************