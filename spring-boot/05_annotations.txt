      ************* Spring Boot Annotations *************

******Core Spring Boot Annotations******

@SpringBootApplication
1. What annotations does it internally include?
   @Configuration, @EnableAutoConfiguration, @ComponentScan

2. Can you replace it with individual annotations?
   Yes, you can replace @SpringBootApplication with individual annotations:

   @Configuration
   @EnableAutoConfiguration
   @ComponentScan
   public class Application {
   }

3. What happens if component scan base package is wrong?
   Spring will not scan the intended packages for components, services, repositories, or configuration classes.
   Beans in those packages will NOT be detected or registered in the application context.
   You may get NoSuchBeanDefinitionException or NullPointerException when trying to autowire missing beans.
   Application startup may fail, or features may not work as expected.

4. How does auto-configuration actually work internally?
   Spring Boot auto-configuration works by:
      1. Scanning the classpath for spring.factories files in all dependencies.
      2. Loading all classes listed under org.springframework.boot.autoconfigure.EnableAutoConfiguration.
      3. Each auto-configuration class is a @Configuration class with @Conditional annotations.
      4. At startup, Spring evaluates the conditions (e.g., is a certain class present? is a property set?).
      5. If conditions are met, beans are created and registered in the context.
      6. User-defined beans or configuration can override auto-configured beans.

****************************************************************************************************

@Configuration
1. Why are @Bean methods inside @Configuration class proxied?
   @Configuration classes are enhanced using CGLIB proxies so Spring can intercept calls to @Bean methods. When one @Bean 
   method calls another inside the same class, the proxy checks the Spring container first and returns the already created 
   singleton bean, instead of executing the method again and creating a new instance.
   This ensures:
      Singleton scope is preserved
      Bean dependencies are managed correctly
      Internal @Bean method calls behave like container lookups, not normal Java calls

2. What happens if you remove @Configuration and keep @Bean?
   If a class has @Bean methods but is not annotated with @Configuration (or not imported as configuration), Spring will not
    process those @Bean methods.
   As a result, the beans will not be created and autowiring those beans will fail.

@Bean
1. When do you prefer @Bean vs @Component?
   Use @Bean when you need to create or configure a bean manually (e.g., third-party classes or custom initialization).
2. Can @Bean methods be private?
   Yes, but bean will not be regitered in the application context and will not be created.


******Dependency Injection Annotations******

@Autowired
1. Constructor vs Field vs Setter injection ‚Äî which is best and why?
   Best: Constructor injection.
   Because it makes dependencies mandatory, supports immutability (final fields), fails fast at startup, and is easiest to unit test.

   Setter injection: use when dependency is optional or needs to change.
   Field injection: avoid‚Äîhard to test, hides dependencies, and encourages mutable design.

2. How does Spring resolve injection at runtime?
   At startup, Spring scans for beans (via @ComponentScan, @Configuration, etc.).
   Spring creates a bean definition for each bean (class or method).
   When a bean is needed (for example, via @Autowired), Spring checks the application context for a matching bean.
   Spring resolves dependencies by type (and optionally by qualifier or name).
   If a dependency is found, Spring injects it (via constructor, setter, or field).
   If multiple candidates exist, Spring uses @Primary or @Qualifier to resolve ambiguity.
   If no candidate is found, or multiple exist without disambiguation, an exception is thrown.
   All this happens at runtime during context initialization.

3. How does @Autowired(required = false) work internally?
   Internally, when Spring processes @Autowired(required = false), it tries to resolve the dependency from the application context, 
   but if no matching bean is found, it does not throw an exception and simply injects null (or skips injection).

@Qualifier
1. When do you need @Qualifier?
   When multiple beans of the same type exist

2. Difference between @Primary and @Qualifier?
   @Primary marks a bean as the default choice when multiple beans of the same type exist.
   @Qualifier is used to explicitly specify which exact bean to inject when multiple candidates are available.

****************************************************************************************************

@Value
1. How does property resolution work and what is loading order of properties (env, yaml, config server, etc)?
Spring Boot resolves properties from multiple sources in a defined order, using the value with the highest precedence.
Properties can be injected using @Value, @ConfigurationProperties, or accessed via the Environment.

Source	                        Example	                        Precedence
Command-line args	               --server.port=9000	            1
System properties	               -Dserver.port=9000	            2
Env variables	                  SERVER_PORT=9000	               3
application.properties / yml	   server.port=9000	               4
Profile-specific properties	   application-dev.properties	      5
Default properties	            Set in code	                     6

****************************************************************************************************

******Web Layer Annotations******
@RestController
1. Difference between @Controller and @RestController?
2. How does Spring convert Java object ‚Üí JSON?

****************************************************************************************************

@RequestMapping, @GetMapping, @PostMapping
1. Can two methods have same path but different params?
2. How does Spring choose correct handler?

****************************************************************************************************

@RequestBody
1. How does Spring deserialize JSON?
2. What happens if request JSON has extra fields?


****************************************************************************************************
************************** Transaction & Data Annotations ***********************
@Transactional

Most Important for Interviews

Questions

Why does @Transactional fail in self-invocation?

What is proxy-based transaction management?

Difference between REQUIRED, REQUIRES_NEW, NESTED?

Production Scenario

Why transaction not rolling back on checked exception?

****************************************************************************************************

@EnableJpaRepositories


What does it actually do internally?

When do you need to explicitly define it?

****************************************************************************************************
*************** Async & Resilience Annotations ******************
@Async
      @Async is a Spring annotation for running methods asynchronously (in a separate thread).
      To use it:
         Add @EnableAsync to a configuration class.
         Annotate a method in a Spring-managed bean with @Async.
         The method can return void, Future<T>, or CompletableFuture<T>.
         When called, the method runs in a background thread, not blocking the caller.
         You can customize the thread pool by defining an Executor bean.

         @EnableAsync
         @SpringBootApplication
         public class App { }

         @Service
         public class NotificationService {

            @Async
            public void sendEmail(String email) {
               System.out.println("Sending email to " + email);
               try { Thread.sleep(3000); } catch (Exception ignored) {}
               System.out.println("Email sent to " + email);
            }
         }

         notificationService.sendEmail("user@gmail.com");
         System.out.println("Request completed");


         Why does @Async fail if method is called internally?
         When you call an @Async method from another bean, the call goes through the proxy ‚Üí Spring intercepts it ‚Üí submits it to the async executor.

         But if you call it internally (same class, this.asyncMethod()), it bypasses the proxy and becomes a normal direct Java method call ‚Üí 
         so it runs synchronously and @Async ‚Äúfails‚Äù.

         @Service
         class MailService {
         @Async void send() { ... }

         void trigger() {
            send(); // internal call -> no proxy -> runs sync
         }
         }


         How do you configure thread pool for @Async?
         @Configuration
         @EnableAsync
         public class AsyncConfig {

         @Bean(name = "asyncExecutor")
         public Executor asyncExecutor() {
            ThreadPoolTaskExecutor exec = new ThreadPoolTaskExecutor();
            exec.setCorePoolSize(10);
            exec.setMaxPoolSize(50);
            exec.setQueueCapacity(500);
            exec.setThreadNamePrefix("async-");
            exec.initialize();
            return exec;
         }
         }

         @Async("asyncExecutor")
         public void sendEmail() { ... }

****************************************************************************************************
@EnableAsync
      It is used to enable asynchronous method execution and it is place on the configuration class.

      What happens if you forget it?
      No @EnableAsync ‚Üí No async thread execution ‚Üí Runs in caller thread

****************************************************************************************************

@Scheduled
      This is used for scheduling the tasks automatically at fixed interval, fixed delay and fixed times. It is used on 
      methods in spring managed beans. It requires @EnableScheduling on configuration class. It supports fixedRate, fixedDelay and
      cron expressions. The method return type should be void and should have no arguments.

      @EnableScheduling
      @SpringBootApplication
      public class App { }


      @Scheduled(fixedRate = 5000)
      public void processJobs() {
         System.out.println("Running every 5 seconds");
      }

      @Scheduled(fixedDelay = 5000)
      public void syncData() {
         System.out.println("Runs 5 sec after previous execution finishes");
      }

      @Scheduled(cron = "0 0 2 * * ?")
      public void generateReport() {
         System.out.println("Daily report job");
      }  


      What happens if scheduled job runs longer than interval?
      If a scheduled job runs longer than its interval:
         1. fixedRate ‚Üí Next execution may start while previous is still running (can overlap if thread pool allows).
         2. fixedDelay ‚Üí Next execution starts only after previous execution finishes + delay.
         3. cron ‚Üí If previous job is still running, next run may wait or overlap depending on scheduler thread pool configuration.      

      How do you prevent overlapping executions?
         In Spring, to prevent overlapping scheduled jobs, use @Scheduled(fixedDelay = ‚Ä¶) instead of fixedRate or cron.
         With fixedDelay, the next execution starts only after the previous execution finishes, ensuring no overlap.
         For @Scheduled(cron = ‚Ä¶), overlapping can occur if the method takes longer than the interval.
         To prevent this, use a single-threaded scheduler.
         Optionally, configure a custom TaskScheduler bean with pool size = 1 to ensure only one job runs at a time, regardless of scheduling type.

****************************************************************************************************

@PreAuthorize : Security Related
      It is a spring security annotaton for method-level authorization. It is used to specify security expression that  
      must evaluate to true before method can be invoked. It is commonly used to restrict access based on roles, authoritoes
      and custom condition. It can be applied to controller and service methods. It requires method security to be enabled with 
       @EnableMethodSecurity or @EnableGlobalMethodSecurity.

      @RestController
      @RequestMapping("/bookings")
      public class BookingController {

         @GetMapping
         @PreAuthorize("hasAuthority('SCOPE_booking:read')")
         public String getBookings() {
            return "Bookings List";
         }

         @PostMapping
         @PreAuthorize("hasRole('ADMIN')")
         public String createBooking() {
            return "Booking created";
         }
      }


      How is it evaluated internally?
      Internal Evaluation (Simple Flow):
         1. When a method with @PreAuthorize is called, Spring AOP intercepts the method call.
         2. Spring‚Äôs Method Security Interceptor evaluates the security expression using SpEL against the current authentication and method context.
         3. If the expression is true, method executes. If false, Spring throws AccessDeniedException (403) and blocks execution.

      Difference vs @Secured?
      This is also spring security method-level annotation, @PreAuthorize used spring expresson language to evaluate to security expression.
      The spring expression language is flexible and can evaluate complex security expressions(role, authorities and custom). While @Secured
      checks for roles only.

      @Service
      public class BookingService {

         @PreAuthorize("hasRole('ADMIN') or hasAuthority('SCOPE_booking:write')")
         public void createBooking() {
            // Complex security logic allowed
         }

         @Secured("ROLE_ADMIN")
         public void deleteBooking() {
            // Only checks for ROLE_ADMIN
         }
      }


****************************************************************************************************

@Timed (Micrometer) : Observability & Actuator
      It is a micrometer annotation(not spring native), it is used to automatically record the execution time of a method.
      When it is applied, it creates a timer metrics with a method's name(or custom name), these metrics can be collected 
      and exported to monitoring systems like Prometheus. This is commonly used in spring boot apps for performance monitoring.

      @Timed(value = "booking.create.time", description = "Time taken to create booking")
      public Booking createBooking(BookingRequest request) {
         return bookingService.create(request);
      }

      Where are metrics stored?
      By default metrics are collected and stored in memory and available via actuator endpoints. if configured then these can be pushed to
      monitoring systems.

      How do you export metrics to Prometheus?
      Add Micrometer Prometheus dependency, enable /actuator/prometheus endpoint, and configure Prometheus to scrape that endpoint. 
      Prometheus periodically scrapes (HTTP GET) metrics from the app endpoint (like /actuator/prometheus).
      App does not push metrics in the standard Prometheus model.

****************************************************************************************************

üß™ Testing Annotations
‚úÖ @SpringBootTest

Questions

Difference vs @WebMvcTest?

Why are tests slow with @SpringBootTest?

‚úÖ @MockBean

Questions

Difference vs Mockito @Mock?


*********************************************************

‚≠ê Ultra-Senior Annotation Questions
üî• Proxy Mechanism Questions

Which annotations depend on AOP proxy?

@Transactional

@Async

@Cacheable

@Retryable

üî• Ordering Questions

What loads first?

Environment

Config files

Auto configuration

User beans


1) Why does @Transactional not work when you call the method from the same class?

What‚Äôs ‚Äúself-invocation‚Äù?

How do Spring proxies apply transactions?

2) @Transactional on a private / final method‚Äîwill it work?

Why/why not?

What about final classes?

3) @Transactional doesn‚Äôt roll back‚Äîwhy?

Checked vs unchecked exceptions

rollbackFor / noRollbackFor

Catching exception and not rethrowing

4) @Async ‚Äúworks‚Äù but still blocks the request‚Äîwhat happened?

Self-invocation again

Wrong executor (sync fallback)

Calling .get() on Future/CompletableFuture

5) @Async + @Transactional together‚Äîwhat‚Äôs the trap?

Transaction context doesn‚Äôt propagate across threads

What is actually transactional: caller or async method?

6) @Scheduled runs in parallel unexpectedly‚Äîwhy?

Default scheduler vs custom scheduler

Multiple instances/pods (Kubernetes) ‚Üí job runs N times

7) How do you prevent @Scheduled from running concurrently across pods?

Distributed lock patterns (ShedLock etc.)

Leader election / single-runner deployment

8) Why does @Cacheable not cache at all?

Same-class call (proxy not used)

Key generation mismatch

Cache manager not configured / wrong cache name

9) @Cacheable caches ‚Äúwrong‚Äù results‚Äîwhat‚Äôs the common cause?

Missing key ‚Üí same key for all calls

Mutable keys / arrays

Caching null vs not caching null

10) @Configuration vs @Component for config classes‚Äîwhat breaks?

@Configuration uses CGLIB proxying

Without it, @Bean method calls create new instances

11) @Bean method calling another @Bean method‚Äîwhy does it sometimes create 2 objects?

Happens when class isn‚Äôt proxied (@Configuration missing or proxyBeanMethods disabled)

12) @SpringBootApplication scanning issue: why aren‚Äôt beans detected?

Component scan starts from the package of the main class

Main class placed in wrong package

13) @Profile confusion: why is a bean created even when profile isn‚Äôt active?

Where @Profile is applied (class vs method)

Default profiles / profile groups

14) @Value injects null or fails‚Äîwhy?

Property not loaded

Wrong property key

Using it too early (static fields / before environment)

Prefer @ConfigurationProperties

15) @ConfigurationProperties binds nothing‚Äîmost common reasons?

Missing @EnableConfigurationProperties / not registered as bean

Wrong prefix

Missing setters / constructor binding mismatch

Using records without proper setup

16) @ConditionalOnProperty behaves opposite of what you expect‚Äîhow?

matchIfMissing=true

Property exists but empty vs missing

Relaxed binding names (my.prop vs MY_PROP)

17) @Primary + @Qualifier together‚Äîwho wins?

@Qualifier wins (it‚Äôs explicit)

Where @Primary helps: ambiguous injection without qualifiers

18) @Autowired with multiple constructors‚Äîwhat happens?

Modern Spring prefers single constructor, autowires it implicitly

If multiple constructors exist: ambiguity unless @Autowired marks one

19) @Order doesn‚Äôt seem to affect your filters/interceptors‚Äîwhy?

@Order affects some types (e.g., FilterRegistrationBean, Ordered)

Security filter chain ordering has its own rules

20) @ControllerAdvice not catching exceptions‚Äîwhy?

Exception thrown before controller (filter/security)

Response already committed

Wrong exception type / handler method signature mismatch



**********************************************************************

Story 1 ‚Äî Transaction Didn‚Äôt Roll Back (Money Lost)
      Production Incident
      Payment deducted. Booking failed. No rollback.
      Root Cause : @Transactional method caught exception and didn‚Äôt rethrow.

      @Transactional
      public void createBooking() {
         try {
            paymentService.pay();
            bookingRepo.save();
         } catch(Exception e) {
            log.error("failed", e);
         }
      }

      Interview Questions

      1. Why transaction didn‚Äôt rollback?
      2. How does Spring decide rollback?
      3. How to fix?

Story 2 ‚Äî @Async Didn‚Äôt Run Async (System Slow)
      Production Incident : Email sending blocking API response.
      Root Cause : Self-invocation.

      public void createBooking() {
         sendEmailAsync(); //  same class call
      }

      @Async
      public void sendEmailAsync() {}

      1. Why async didn‚Äôt work?
      2. How does proxy work?
      3. Fix?


Story 3 ‚Äî Cache Not Working (DB Overloaded)
      Incident : Cache annotation present but DB still hit every time.

      @Cacheable("users")
      public User getUser(String id) {}

      Root Cause : Method called internally OR cache key issue.

      1. When cache won‚Äôt work?
      2. How key generated?
      3. How to debug cache?

Story 4 ‚Äî Scheduled Job Ran 6 Times (Data Corruption)
      Incident : Cron job executed once per pod in Kubernetes.

      1. Why did it run multiple times?
      2. How to make singleton execution?

Story 5 ‚Äî Two Beans Created Instead of One
      Incident: Connection pool created twice ‚Üí DB exhaustion.

      @Component
      public class AppConfig {

         @Bean
         public DataSource ds() { return new HikariDataSource(); }

         @Bean
         public Service service() { return new Service(ds()); } // ‚ùå
      }

      1. Why two instances?
      2. Difference if using @Configuration?

Story 6 ‚Äî Transaction Ignored (Self Invocation)
      Incident : Audit record saved even when main transaction failed.

      @Transactional
      public void main() {
         saveAudit(); // 
      }

      @Transactional
      public void saveAudit() {}

      1. Why second transaction not applied?

Story 7 ‚Äî @Value Null in Production Only
      Incident : Local works, prod fails.
      Root Causes : Env variable naming mismatch
      Property not loaded
      Early bean initialization

Story 8 ‚Äî @ConfigurationProperties Not Binding
      Incident : Config values always default.

      1. Why binding may fail?
      2. Difference vs @Value?

Story 9 ‚Äî Security Annotation Ignored
      Incident : @PreAuthorize not enforced.

      Root Cause
      1. Method called internally OR security not enabled.

Story 10 ‚Äî @ConditionalOnProperty Wrong Behavior
      Incident : Feature disabled but bean still created.

      Root Cause : matchIfMissing=true

Story 11 ‚Äî Multiple Bean Injection Crash
      Incident : NoUniqueBeanDefinitionException

      1. When to use @Primary vs @Qualifier?

Story 12 ‚Äî @Lazy Caused Runtime Failure
      Incident : Bean initialized late ‚Üí config missing ‚Üí crash later.

Story 13 ‚Äî @Profile Wrong Bean Loaded
      Incident : Dev DB used in production.

Story 14 ‚Äî @ControllerAdvice Not Catching Exceptions
      Root Cause : Exception thrown in filter OR response committed.

Story 15 ‚Äî @RestController Returning HTML
      Root Cause : Content negotiation / Accept header mismatch.

Story 16 ‚Äî @RequestBody Deserialization Failure
      Root Causes : Missing default constructor, Jackson config mismatch

Story 17 ‚Äî @Transactional(readOnly=true) Still Writing
      Root Cause : Some DBs ignore read-only flag.

Story 18 ‚Äî @EnableAsync Missing
      Root Cause : Async silently runs sync.

Story 19 ‚Äî @Order Not Working
      Root Cause : Not all components respect @Order.

Story 20 ‚Äî Annotation Works Locally But Not In Prod
      Root Causes : Proxy disabled, Different bean lifecycle, Missing config class scanning
